#!/usr/bin/env python3
"""
Flawed ECDSA Signer - Demonstrates nonce reuse and affine nonce relationships.

This module creates ECDSA (secp256k1) signatures with:
1. Same nonce reuse (k1 = k2) - simplest attack case
2. Affinely related nonces (k2 = a*k1 + b) - for testing recovery attacks
3. Random nonces (non-standard ECDSA) - implementation bug scenario

WARNING: This is for testing/educational purposes only!
Standard ECDSA should use cryptographically secure random nonces.

CRITICAL RULES for flawed nonce generation:
1. Use raw nonce scalars directly
2. Affine relations must be on k scalars: k2 = (α*k1 + β) % n
3. Use the SAME k for r and s: r = (k*G).x(), s = k^(-1) * (z + r*d)
4. Do NOT modify k after generation
"""

import hashlib
import json
import os
import secrets
from typing import List, Tuple, Optional
from ecdsa import SigningKey, SECP256k1, VerifyingKey


# secp256k1 curve order
CURVE_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141


class FlawedSigner:
    """
    A flawed ECDSA signer that uses random nonces with reuse or affine relationships.
    
    Note: Standard ECDSA uses cryptographically secure random nonces.
    This class simulates a flawed implementation that uses predictable nonces, making it
    vulnerable to key recovery attacks.
    
    CRITICAL: All flawed nonce patterns are generated by sign_with_affine_nonces.
    """
    
    def __init__(self, private_key: Optional[int] = None):
        """
        Initialize the signer.
        
        Args:
            private_key: Optional private key (generates new one if not provided)
        """
        if private_key:
            self.sk = SigningKey.from_secret_exponent(private_key, curve=SECP256k1)
            self.private_key = private_key
        else:
            self.sk = SigningKey.generate(curve=SECP256k1)
            self.private_key = self.sk.privkey.secret_multiplier
        
        self.vk = self.sk.verifying_key
        
        # Get public key
        x = self.vk.pubkey.point.x()
        y = self.vk.pubkey.point.y()
        prefix = b'\x02' if y % 2 == 0 else b'\x03'
        self.public_key = prefix + x.to_bytes(32, 'big')
    
    def hash_message(self, message: bytes) -> int:
        """Hash a message using SHA-256."""
        h = hashlib.sha256(message).digest()
        return int.from_bytes(h, 'big') % CURVE_ORDER
    
    def sign_with_same_nonce(
        self,
        messages: List[bytes],
        nonce: Optional[int] = None
    ) -> List[dict]:
        """
        Sign multiple messages using the SAME nonce (nonce reuse attack).
        
        This is a special case of affine relationship: k2 = 1*k1 + 0
        
        Args:
            messages: List of messages to sign
            nonce: Optional nonce scalar (generates random one if not provided)
        
        Returns:
            List of signature dictionaries with z, r, s values
        """
        # Same nonce reuse: k2 = 1*k1 + 0 (all nonces are the same)
        return self.sign_with_affine_nonces(messages, a=1, b=0, start_nonce=nonce)
    
    def sign_with_affine_nonces(
        self,
        messages: List[bytes],
        a: int,
        b: int,
        start_nonce: Optional[int] = None
    ) -> List[dict]:
        """
        Sign messages using affinely related nonces: k_i = a*k_{i-1} + b.
        
        This simulates a flawed implementation where nonces have an affine relationship.
        
        CRITICAL RULES:
        1. Use raw nonce scalars directly
        2. Affine relations must be on k scalars: k2 = (α*k1 + β) % n
        3. Use the SAME k for r and s: r = (k*G).x(), s = k^(-1) * (z + r*d)
        4. Do NOT modify k after generation
        
        Args:
            messages: List of messages to sign
            a: Affine coefficient (k2 = a*k1 + b)
            b: Affine offset (k2 = a*k1 + b)
            start_nonce: Optional starting nonce (generates random one if not provided)
        
        Returns:
            List of signature dictionaries with z, r, s values
        """
        if start_nonce is None:
            start_nonce = secrets.randbelow(CURVE_ORDER)
        
        signatures = []
        curve = SECP256k1
        G = curve.generator
        n = curve.order
        
        # CRITICAL: Use raw nonce scalars, no modification
        # The affine relationship k2 = a*k1 + b must hold on the scalar values
        current_k = start_nonce % n
        
        for i, message in enumerate(messages):
            # Use the SAME k scalar for both r and s computation
            k = current_k
            
            # Compute r = (k * G).x() mod n
            r = (k * G).x() % n
            
            # Hash message
            z = self.hash_message(message)
            
            # Compute s = k^(-1) * (z + r * d) mod n
            # CRITICAL: Use the SAME k scalar that was used for r computation
            k_inv = pow(k, -1, n)
            s = (k_inv * (z + r * self.private_key)) % n
            
            signatures.append({
                'message': message.decode('utf-8') if isinstance(message, bytes) else message,
                'z': z,
                'r': r,
                's': s
            })
            
            # Calculate next nonce: k_{i+1} = (a*k_i + b) % n
            # CRITICAL: Apply affine relationship on raw scalars (no modification)
            if i < len(messages) - 1:
                current_k = (a * k + b) % n
        
        return signatures
    
    def sign_with_counter_nonce(
        self,
        messages: List[bytes],
        start_nonce: Optional[int] = None
    ) -> List[dict]:
        """
        Sign messages with counter-based nonces: k_i = k_0 + i.
        
        This is a special case of affine relationship: k_i = 1*k_0 + i
        
        Args:
            messages: List of messages to sign
            start_nonce: Optional starting nonce (generates random one if not provided)
        
        Returns:
            List of signature dictionaries with z, r, s values
        """
        # Counter: k_i = k_0 + i = 1*k_0 + i
        # This is affine with a=1, b=i (but b changes per signature)
        # For simplicity, use step-based: k_i = k_0 + i*1
        return self.sign_with_affine_nonces(messages, a=1, b=1, start_nonce=start_nonce)
    
    def sign_with_hardcoded_step(
        self,
        messages: List[bytes],
        step: int,
        start_nonce: Optional[int] = None
    ) -> List[dict]:
        """
        Sign messages with hardcoded step: k_i = k_0 + i*step.
        
        This is a special case of affine relationship: k_i = 1*k_0 + i*step
        
        Args:
            messages: List of messages to sign
            step: Step size between nonces
            start_nonce: Optional starting nonce
        
        Returns:
            List of signature dictionaries with z, r, s values
        """
        # Hardcoded step: k_i = k_0 + i*step = 1*k_0 + i*step
        # For each signature pair (i, i+1): k_{i+1} = k_i + step = 1*k_i + step
        # This is affine with a=1, b=step
        return self.sign_with_affine_nonces(messages, a=1, b=step, start_nonce=start_nonce)
    
    def save_signatures(self, signatures: List[dict], filename: str):
        """Save signatures to a JSON file in the fixtures folder."""
        # Ensure fixtures directory exists
        fixtures_dir = os.path.join(os.path.dirname(__file__), "..", "fixtures")
        os.makedirs(fixtures_dir, exist_ok=True)
        
        # Save to fixtures folder
        fixtures_path = os.path.join(fixtures_dir, filename)
        with open(fixtures_path, 'w') as f:
            json.dump(signatures, f, indent=2)
        print(f"Saved {len(signatures)} signatures to {fixtures_path}")
    
    def get_key_info(self) -> dict:
        """Get private and public key information."""
        return {
            'private_key': self.private_key,
            'public_key_hex': self.public_key.hex(),
            'public_key_compressed': self.public_key.hex()
        }


def main():
    """Generate test fixtures with various nonce flaws."""
    print("Generating ECDSA test fixtures with flawed nonce generation...")
    
    # Create signer
    signer = FlawedSigner()
    key_info = signer.get_key_info()
    
    # Save key info
    os.makedirs('fixtures', exist_ok=True)
    with open('fixtures/test_key_info.json', 'w') as f:
        json.dump(key_info, f, indent=2)
    print(f"Saved key info to fixtures/test_key_info.json")
    print(f"Private key: {key_info['private_key']}")
    print(f"Public key: {key_info['public_key_hex']}\n")
    
    # Generate test messages
    messages = [
        b"Transaction 1: Send 1 ETH",
        b"Transaction 2: Send 2 ETH",
        b"Transaction 3: Send 3 ETH",
        b"Transaction 4: Send 4 ETH",
        b"Transaction 5: Send 5 ETH"
    ]
    
    # 1. Same nonce reuse
    print("1. Generating same nonce reuse signatures...")
    same_nonce_sigs = signer.sign_with_same_nonce(messages)
    with open('fixtures/test_signatures_same_nonce.json', 'w') as f:
        json.dump(same_nonce_sigs, f, indent=2)
    print(f"   Saved {len(same_nonce_sigs)} signatures to fixtures/test_signatures_same_nonce.json")
    
    # 2. Counter nonces (k_i = k_0 + i)
    print("2. Generating counter nonce signatures...")
    counter_sigs = signer.sign_with_counter_nonce(messages)
    with open('fixtures/test_signatures_counter.json', 'w') as f:
        json.dump(counter_sigs, f, indent=2)
    print(f"   Saved {len(counter_sigs)} signatures to fixtures/test_signatures_counter.json")
    
    # 3. Affine relationship (k2 = 2*k1 + 1)
    print("3. Generating affine relationship signatures (k2 = 2*k1 + 1)...")
    affine_sigs = signer.sign_with_affine_nonces(messages, a=2, b=1)
    with open('fixtures/test_signatures_affine.json', 'w') as f:
        json.dump(affine_sigs, f, indent=2)
    print(f"   Saved {len(affine_sigs)} signatures to fixtures/test_signatures_affine.json")
    
    # 4. Hardcoded step (k_i = k_0 + i*step)
    print("4. Generating hardcoded step signatures (k_i = k_0 + i*12345).")
    step_sigs = signer.sign_with_hardcoded_step(messages, step=12345)
    with open('fixtures/test_signatures_hardcoded_step.json', 'w') as f:
        json.dump(step_sigs, f, indent=2)
    print(f"   Saved {len(step_sigs)} signatures to fixtures/test_signatures_hardcoded_step.json")
    
    print("\n✅ All test fixtures generated successfully!")
    print("\nNote: All signatures use RANDOM nonces with affine relationships (non-standard ECDSA) for attack testing.")


if __name__ == '__main__':
    main()
