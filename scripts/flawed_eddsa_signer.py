#!/usr/bin/env python3
"""
Flawed EdDSA Signer - Demonstrates nonce reuse and affine nonce relationships.

This module creates EdDSA (Ed25519) signatures with:
1. Same nonce reuse (r1 = r2) - simplest attack case
2. Affinely related nonces (r2 = a*r1 + b) - for testing recovery attacks
3. Random nonces (non-standard EdDSA) - implementation bug scenario

WARNING: This is for testing/educational purposes only!
Standard EdDSA uses deterministic nonces, but this simulates flawed implementations.

CRITICAL RULES for flawed nonce generation:
1. Never clamp nonces - use raw scalars
2. Affine relations must be on r scalars: r2 = (α*r1 + β) % ℓ
3. Use the SAME r for R and S: R = r*B, S = r + k*a
4. Do NOT re-encode, re-clamp, or adjust r
"""

import hashlib
import json
import os
import secrets
from typing import List, Tuple, Optional
from nacl.signing import SigningKey, VerifyKey
from nacl.encoding import RawEncoder, HexEncoder
import nacl.bindings


# Ed25519 curve order
CURVE_ORDER = 2**252 + 27742317777372353535851937790883648493


class FlawedEdDSASigner:
    """
    A flawed EdDSA signer that uses random nonces (non-standard) with reuse or affine relationships.
    
    Note: Standard EdDSA uses deterministic nonces (SHA-512(private_key || message)).
    This class simulates a flawed implementation that uses random nonces, making it
    vulnerable to the same attacks as ECDSA.
    
    CRITICAL: All flawed nonce patterns are generated by sign_with_affine_nonces.
    """
    
    def __init__(self, private_key: Optional[bytes] = None):
        """
        Initialize the signer.
        
        Args:
            private_key: Optional 32-byte private key (generates new one if not provided)
        """
        if private_key:
            if len(private_key) != 32:
                raise ValueError("Private key must be 32 bytes")
            self.sk = SigningKey(private_key)
            self.private_key = private_key
        else:
            self.sk = SigningKey.generate()
            self.private_key = self.sk.encode(encoder=RawEncoder)
        
        self.vk = self.sk.verify_key
        self.public_key = self.vk.encode(encoder=RawEncoder)
    
    def hash_message(self, message: bytes) -> bytes:
        """Hash a message using SHA-512 (EdDSA standard)."""
        return hashlib.sha512(message).digest()
    
    def compute_h(self, r: bytes, public_key: bytes, message: bytes) -> int:
        """
        Compute H(R||A||M) for EdDSA signature.
        
        Args:
            r: R point (32 bytes)
            public_key: Public key A (32 bytes)
            message: Message bytes
            
        Returns:
            Integer hash value mod curve order
        """
        data = r + public_key + message
        h = hashlib.sha512(data).digest()
        # Reduce mod curve order
        return int.from_bytes(h, 'little') % CURVE_ORDER
    
    def sign_with_same_nonce(
        self,
        messages: List[bytes],
        nonce: Optional[int] = None
    ) -> List[dict]:
        """
        Sign multiple messages using the SAME nonce (nonce reuse attack).
        
        This is a special case of affine relationship: r2 = 1*r1 + 0
        
        Args:
            messages: List of messages to sign
            nonce: Optional nonce scalar (generates random one if not provided)
        
        Returns:
            List of signature dictionaries with r, s, message values
        """
        # Same nonce reuse: r2 = 1*r1 + 0 (all nonces are the same)
        return self.sign_with_affine_nonces(messages, a=1, b=0, start_nonce=nonce)
    
    def sign_with_affine_nonces(
        self,
        messages: List[bytes],
        a: int,
        b: int,
        start_nonce: Optional[int] = None
    ) -> List[dict]:
        """
        Sign messages using affinely related nonces: r_i = a*r_{i-1} + b.
        
        This simulates a flawed implementation where nonces have an affine relationship.
        
        CRITICAL RULES:
        1. Never clamp nonces - use raw scalars
        2. Affine relations must be on r scalars: r2 = (α*r1 + β) % ℓ
        3. Use the SAME r for R and S: R = r*B, S = r + k*a
        4. Do NOT re-encode, re-clamp, or adjust r
        
        Args:
            messages: List of messages to sign
            a: Affine coefficient (r2 = a*r1 + b)
            b: Affine offset (r2 = a*r1 + b)
            start_nonce: Optional starting nonce (generates random one if not provided)
        
        Returns:
            List of signature dictionaries with r, s, message values
        """
        if start_nonce is None:
            start_nonce = secrets.randbelow(CURVE_ORDER)
        
        signatures = []
        
        # CRITICAL: Use raw nonce scalars, NO CLAMPING
        # The affine relationship r2 = a*r1 + b must hold on the scalar values
        current_r = start_nonce % CURVE_ORDER
        
        # Derive private key scalar once (Ed25519 standard: SHA-512 then clamp)
        h_priv = hashlib.sha512(self.private_key).digest()
        a_bytes = bytearray(h_priv[:32])
        # Clamp the private key scalar (Ed25519 requirement for private key only)
        a_bytes[0] &= 0xf8  # Clear bottom 3 bits
        a_bytes[31] &= 0x7f  # Clear top bit
        a_bytes[31] |= 0x40  # Set second-highest bit
        a_priv = int.from_bytes(bytes(a_bytes), 'little') % CURVE_ORDER
        
        for i, message in enumerate(messages):
            # Use the SAME r scalar for both R and S computation
            r = current_r
            
            # Convert r to 32-byte little-endian for point multiplication
            # CRITICAL: Do NOT clamp - use raw scalar bytes
            r_bytes = r.to_bytes(32, 'little')
            # Pad to 32 bytes if needed
            if len(r_bytes) < 32:
                r_bytes = r_bytes + b'\x00' * (32 - len(r_bytes))
            elif len(r_bytes) > 32:
                r_bytes = r_bytes[:32]
            
            # Compute R = r * B (base point)
            # Use noclamp because we're using raw nonce scalar (not clamped)
            R_point = nacl.bindings.crypto_scalarmult_ed25519_base_noclamp(r_bytes)
            r_bytes_encoded = R_point  # R point as 32-byte compressed format
            r_int = int.from_bytes(r_bytes_encoded, 'little')
            
            # Compute challenge: k = H(R || A || M) mod ℓ
            k = self.compute_h(r_bytes_encoded, self.public_key, message)
            
            # Compute signature scalar: S = (r + k*a) mod ℓ
            # CRITICAL: Use the SAME r scalar that was used for R computation
            s = (r + k * a_priv) % CURVE_ORDER
            
            signatures.append({
                'message': message.hex(),
                'r': hex(r_int),
                's': hex(s),
                'public_key': self.public_key.hex(),
            })
            
            # Calculate next nonce: r_{i+1} = (a*r_i + b) % ℓ
            # CRITICAL: Apply affine relationship on raw scalars (no clamping)
            if i < len(messages) - 1:
                current_r = (a * r + b) % CURVE_ORDER
        
        return signatures
    
    def sign_with_counter_nonce(
        self,
        messages: List[bytes],
        start_nonce: Optional[int] = None
    ) -> List[dict]:
        """
        Sign messages with counter-based nonces: r_i = r_0 + i.
        
        This is a special case of affine relationship: r_i = 1*r_0 + i
        
        Args:
            messages: List of messages to sign
            start_nonce: Optional starting nonce (generates random one if not provided)
        
        Returns:
            List of signature dictionaries
        """
        # Counter: r_i = r_0 + i = 1*r_0 + i
        # This is affine with a=1, b=i (but b changes per signature)
        # For simplicity, use step-based: r_i = r_0 + i*1
        return self.sign_with_affine_nonces(messages, a=1, b=1, start_nonce=start_nonce)
    
    def sign_with_hardcoded_step(
        self,
        messages: List[bytes],
        step: int,
        start_nonce: Optional[int] = None
    ) -> List[dict]:
        """
        Sign messages with hardcoded step: r_i = r_0 + i*step.
        
        This is a special case of affine relationship: r_i = 1*r_0 + i*step
        
        Args:
            messages: List of messages to sign
            step: Step size between nonces
            start_nonce: Optional starting nonce
        
        Returns:
            List of signature dictionaries
        """
        # Hardcoded step: r_i = r_0 + i*step = 1*r_0 + i*step
        # For each signature pair (i, i+1): r_{i+1} = r_i + step = 1*r_i + step
        # This is affine with a=1, b=step
        return self.sign_with_affine_nonces(messages, a=1, b=step, start_nonce=start_nonce)
    
    def sign_with_standard_ed25519(self, messages: List[bytes]) -> List[dict]:
        """
        Sign messages using STANDARD Ed25519 (deterministic nonce generation).
        
        This creates correct, verifiable Ed25519 signatures that:
        - Use deterministic nonces: r = SHA-512(private_key || message)
        - Can be verified with standard Ed25519 verification
        - Cannot be brute-forced (no affine relationships)
        - Test that the signing infrastructure is correct
        
        Uses nacl's built-in signing to ensure correct format, then extracts R and s.
        
        Args:
            messages: List of messages to sign
            
        Returns:
            List of signature dictionaries with r, s, message, public_key values
        """
        signatures = []
        
        for message in messages:
            # Use nacl's built-in signing (standard Ed25519)
            # This ensures the signature is in the correct format and can be verified
            nacl_signature = self.sk.sign(message)
            
            # Extract R and s from the 64-byte signature
            # Ed25519 signature format: R (32 bytes) || s (32 bytes)
            sig_bytes = bytes(nacl_signature.signature)
            r_bytes = sig_bytes[:32]
            s_bytes = sig_bytes[32:64]
            
            # Convert to integers for output format (little-endian)
            # Ed25519 stores R and s in little-endian byte format
            r_int = int.from_bytes(r_bytes, 'little')
            s_int = int.from_bytes(s_bytes, 'little')
            
            # Format as hex strings (big-endian representation of the integer)
            # Match the format from test_eddsa_signatures_standard.json:
            # - r: "0x..." (hex string with 0x prefix, padded to 64 hex chars = 32 bytes)
            # - s: "0x..." (hex string with 0x prefix, padded to 64 hex chars = 32 bytes)
            # This ensures compatibility with eddsaaffine package
            r_hex_raw = hex(r_int)[2:]  # Remove 0x prefix
            s_hex_raw = hex(s_int)[2:]  # Remove 0x prefix
            
            # Pad with leading zeros to ensure exactly 64 hex characters (32 bytes)
            r_hex = "0x" + r_hex_raw.zfill(64)
            s_hex = "0x" + s_hex_raw.zfill(64)
            
            signatures.append({
                'message': message.hex(),
                'r': r_hex,  # Padded to 64 hex chars
                's': s_hex,  # Padded to 64 hex chars
                'public_key': self.public_key.hex(),
            })
        
        return signatures
    
    def get_key_info(self) -> dict:
        """Get private and public key information."""
        return {
            'private_key': int.from_bytes(self.private_key[:32], 'little'),
            'public_key_hex': self.public_key.hex(),
            'public_key': self.public_key.hex(),
        }


def main():
    """Generate test fixtures with various nonce flaws."""
    print("Generating EdDSA test fixtures with flawed nonce generation...")
    
    # Create signer
    signer = FlawedEdDSASigner()
    key_info = signer.get_key_info()
    
    # Save key info
    os.makedirs('fixtures', exist_ok=True)
    with open('fixtures/test_eddsa_key_info.json', 'w') as f:
        json.dump(key_info, f, indent=2)
    print(f"Saved key info to fixtures/test_eddsa_key_info.json")
    print(f"Private key: {key_info['private_key']}")
    print(f"Public key: {key_info['public_key_hex']}\n")
    
    # Generate test messages
    messages = [f"Test message {i}".encode() for i in range(5)]
    
    # 1. Same nonce reuse
    print("1. Generating same nonce reuse signatures...")
    same_nonce_sigs = signer.sign_with_same_nonce(messages)
    with open('fixtures/test_eddsa_signatures_same_nonce.json', 'w') as f:
        json.dump(same_nonce_sigs, f, indent=2)
    print(f"   Saved {len(same_nonce_sigs)} signatures to fixtures/test_eddsa_signatures_same_nonce.json")
    
    # 2. Counter nonces (r_i = r_0 + i)
    print("2. Generating counter nonce signatures...")
    counter_sigs = signer.sign_with_counter_nonce(messages)
    with open('fixtures/test_eddsa_signatures_counter.json', 'w') as f:
        json.dump(counter_sigs, f, indent=2)
    print(f"   Saved {len(counter_sigs)} signatures to fixtures/test_eddsa_signatures_counter.json")
    
    # 3. Affine relationship (r2 = 2*r1 + 1)
    print("3. Generating affine relationship signatures (r2 = 2*r1 + 1)...")
    affine_sigs = signer.sign_with_affine_nonces(messages, a=2, b=1)
    with open('fixtures/test_eddsa_signatures_affine.json', 'w') as f:
        json.dump(affine_sigs, f, indent=2)
    print(f"   Saved {len(affine_sigs)} signatures to fixtures/test_eddsa_signatures_affine.json")
    
    # 4. Hardcoded step (r_i = r_0 + i*step)
    print("4. Generating hardcoded step signatures (r_i = r_0 + i*73).")
    step_sigs = signer.sign_with_hardcoded_step(messages, step=13511)
    with open('fixtures/test_eddsa_signatures_hardcoded_step.json', 'w') as f:
        json.dump(step_sigs, f, indent=2)
    print(f"   Saved {len(step_sigs)} signatures to fixtures/test_eddsa_signatures_hardcoded_step.json")
    
    # 5. Standard Ed25519 (correct signatures for verification testing)
    print("5. Generating standard Ed25519 signatures (deterministic nonces)...")
    standard_sigs = signer.sign_with_standard_ed25519(messages)
    with open('fixtures/test_eddsa_signatures_standard.json', 'w') as f:
        json.dump(standard_sigs, f, indent=2)
    print(f"   Saved {len(standard_sigs)} signatures to fixtures/test_eddsa_signatures_standard.json")
    
    # Verify the standard signatures to ensure they're correct
    print("\n   Verifying standard signatures...")
    from nacl.signing import VerifyKey
    vk = VerifyKey(signer.public_key)
    verified_count = 0
    for sig in standard_sigs:
        message_bytes = bytes.fromhex(sig['message'])
        # Convert R and s from hex strings (big-endian) back to little-endian bytes
        r_int = int(sig['r'], 16)
        s_int = int(sig['s'], 16)
        # Convert to bytes (little-endian, 32 bytes each)
        r_bytes = r_int.to_bytes(32, 'little')
        s_bytes = s_int.to_bytes(32, 'little')
        full_sig = r_bytes + s_bytes
        try:
            vk.verify(message_bytes, full_sig)
            verified_count += 1
        except Exception:
            pass
    print(f"   ✅ {verified_count}/{len(standard_sigs)} signatures verified successfully")
    
    print("\n✅ All test fixtures generated successfully!")
    print("\nNote: Signatures 1-4 use RANDOM nonces (non-standard EdDSA) for attack testing.")
    print("      Signature 5 uses STANDARD Ed25519 (deterministic nonces) for verification testing.")


if __name__ == '__main__':
    main()
