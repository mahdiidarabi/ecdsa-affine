package ecdsaaffine

import (
	"context"
	"math/big"
	"path/filepath"
	"testing"
)

func TestClient_RecoverKeyWithKnownRelationship(t *testing.T) {
	client := NewClient()
	keyInfo, err := loadTestKeyInfo()
	if err != nil {
		t.Fatalf("Failed to load key info: %v", err)
	}
	ctx := context.Background()

	// Test with counter signatures (k2 = k1 + 1, so a=1, b=1)
	result, err := client.RecoverKeyWithKnownRelationship(ctx, filepath.Join(fixturesDir(), "test_signatures_counter.json"), 1, 1, keyInfo.PublicKeyHex)
	if err != nil {
		t.Fatalf("Failed to recover key: %v", err)
	}
	if result == nil || result.PrivateKey == nil {
		t.Fatal("Result is nil")
	}
	if !result.Verified {
		t.Error("Key should be verified")
	}
	expectedPriv := big.NewInt(0)
	expectedPriv.SetString(keyInfo.PrivateKey, 10)
	if result.PrivateKey.Cmp(expectedPriv) != 0 {
		t.Errorf("Recovered key mismatch. Got: %s, Expected: %s",
			result.PrivateKey.Text(10), expectedPriv.Text(10))
	}
}

// Table-driven tests for RecoverKeyWithKnownRelationship (researcher-friendly).
func TestClient_RecoverKeyWithKnownRelationship_Table(t *testing.T) {
	client := NewClient()
	keyInfo, err := loadTestKeyInfo()
	if err != nil {
		t.Fatalf("Failed to load key info: %v", err)
	}
	ctx := context.Background()
	expectedPriv := big.NewInt(0)
	expectedPriv.SetString(keyInfo.PrivateKey, 10)

	// Only include cases where (a,b) is fixed by the fixture format.
	// hardcoded_step is omitted: step value can be 12345 or 12375 depending on
	// whether fixtures were generated by flawed_signer.py or generate_fixtures.py.
	tests := []struct {
		name    string
		file    string
		a, b    int64
		wantErr bool
	}{
		{"counter k2=k1+1", "test_signatures_counter.json", 1, 1, false},
		{"same_nonce k2=k1", "test_signatures_same_nonce.json", 1, 0, false},
		{"affine k2=2*k1+1", "test_signatures_affine.json", 2, 1, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := client.RecoverKeyWithKnownRelationship(ctx, filepath.Join(fixturesDir(), tt.file), tt.a, tt.b, keyInfo.PublicKeyHex)
			if tt.wantErr {
				if err == nil {
					t.Error("Expected error")
				}
				return
			}
			if err != nil {
				t.Fatalf("RecoverKeyWithKnownRelationship: %v", err)
			}
			if result == nil || !result.Verified {
				t.Error("Expected verified result")
			}
			if result.PrivateKey.Cmp(expectedPriv) != 0 {
				t.Errorf("Recovered key mismatch")
			}
		})
	}
}


func TestClient_RecoverKey_SmartBruteForce(t *testing.T) {
	client := NewClient()

	keyInfo, err := loadTestKeyInfo()
	if err != nil {
		t.Fatalf("Failed to load key info: %v", err)
	}

	ctx := context.Background()

	// This will use smart brute-force to find the relationship
	// For counter signatures, it should find k2 = k1 + 1 quickly
	result, err := client.RecoverKey(ctx, filepath.Join(fixturesDir(), "test_signatures_counter.json"), keyInfo.PublicKeyHex)
	if err != nil {
		t.Logf("Brute-force recovery failed (this is expected if it takes too long): %v", err)
		return // Don't fail the test if brute-force doesn't complete quickly
	}

	if result != nil {
		if !result.Verified {
			t.Error("Recovered key should be verified")
		}
		t.Logf("Successfully recovered key with smart brute-force. Pattern: %s", result.Pattern)
	}
}

func TestClient_WithStrategy(t *testing.T) {
	strategy := NewSmartBruteForceStrategy().
		WithRangeConfig(RangeConfig{
			ARange:     [2]int{1, 1},
			BRange:     [2]int{-10, 10},
			MaxPairs:   10,
			NumWorkers: 4,
			SkipZeroA:  true,
		})

	client := NewClient().WithStrategy(strategy)

	if client.strategy == nil {
		t.Error("Strategy should be set")
	}

	if client.strategy.Name() != "SmartBruteForce" {
		t.Errorf("Expected strategy name 'SmartBruteForce', got '%s'", client.strategy.Name())
	}
}

func TestClient_WithParser(t *testing.T) {
	parser := &JSONParser{
		MessageField: "message",
		RField:       "r",
		SField:       "s",
	}

	client := NewClient().WithParser(parser)

	if client.parser == nil {
		t.Error("Parser should be set")
	}
}

func TestClient_RecoverKeyFromSignatures(t *testing.T) {
	client := NewClient()
	keyInfo, err := loadTestKeyInfo()
	if err != nil {
		t.Fatalf("Failed to load key info: %v", err)
	}
	signatures, err := loadTestSignatures("test_signatures_counter.json")
	if err != nil {
		t.Fatalf("Failed to load signatures: %v", err)
	}

	ctx := context.Background()
	result, err := client.RecoverKeyFromSignatures(ctx, signatures, keyInfo.PublicKeyHex)
	if err != nil {
		t.Fatalf("RecoverKeyFromSignatures failed: %v", err)
	}
	if result == nil || !result.Verified {
		t.Fatal("Expected verified result")
	}
	expectedPriv := big.NewInt(0)
	expectedPriv.SetString(keyInfo.PrivateKey, 10)
	if result.PrivateKey.Cmp(expectedPriv) != 0 {
		t.Errorf("Recovered key mismatch")
	}
}

func TestCommonPatterns(t *testing.T) {
	patterns := CommonPatterns()
	if len(patterns) == 0 {
		t.Fatal("CommonPatterns() should return non-empty list")
	}
	// Ensure it's a copy (researchers can modify without affecting defaults)
	patterns[0].Name = "mutated"
	patterns2 := CommonPatterns()
	if patterns2[0].Name == "mutated" {
		t.Error("CommonPatterns() should return a copy, not shared slice")
	}
}
